==== ./package.json ====
{
  "name": "red-tetris",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@reduxjs/toolkit": "^2.3.0",
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "express": "^4.21.1",
    "immutable": "^5.0.0",
    "lodash": "^4.17.21",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-redux": "^9.1.2",
    "react-router-dom": "^6.28.0",
    "react-scripts": "5.0.1",
    "redux": "^5.0.1",
    "redux-devtools-extension": "^2.13.9",
    "redux-promise": "^0.6.0",
    "socket.io": "^4.8.1",
    "socket.io-client": "^4.8.1",
    "uuid": "^11.0.2",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "server": "node server/index.js"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@babel/plugin-proposal-private-property-in-object": "^7.21.11"
  }
}
-e 

==== ./.env ====
REACT_APP_API_URL=http://localhost:3000
REACT_APP_SOCKET_SERVER=http://localhost:4000
-e 

==== ./src/redux/actions/gameActions.js ====
// ./src/redux/actions/gameActions.js

export const updateGameState = (gameState) => ({
  type: "UPDATE_GAME_STATE",
  payload: gameState,
});
-e 

==== ./src/redux/store.js ====
// ./src/redux/store.js

import { configureStore, getDefaultMiddleware } from "@reduxjs/toolkit";
import promiseMiddleware from "redux-promise";
import rootReducer from "./reducers";

const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        // Ignorer les chemins des slices 'test' et 'game'
        ignoredPaths: ["test", "game"],
      },
    }).concat(promiseMiddleware),
  devTools: process.env.NODE_ENV !== "production",
});

export default store;
-e 

==== ./src/redux/reducers/index.js ====
// ./src/redux/reducers/index.js : Combine tous les reducers en un rootReducer.

import { combineReducers } from "redux";
import testReducer from "./testReducer";
import gameReducer from "./gameReducer"; // Import du nouveau reducer

const rootReducer = combineReducers({
  test: testReducer,
  game: gameReducer, // Ajout du reducer du jeu
});

export default rootReducer;
-e 

==== ./src/redux/reducers/testReducer.js ====
// testReducer.js : Un reducer de test pour vérifier que Redux fonctionne.

import { Map } from "immutable";

const initialState = Map({
  message: "Hello from Redux!",
});

function testReducer(state = initialState, action) {
  switch (action.type) {
    default:
      return state;
  }
}

export default testReducer;
-e 

==== ./src/redux/reducers/gameReducer.js ====
// ./src/redux/reducers/gameReducer.js

import { Map } from "immutable";

const initialState = Map({
  grid: Array.from({ length: 20 }, () => Array(10).fill(0)),
  currentPiece: null,
  score: 0,
  mode: "multiplayer", // Valeur par défaut, à mettre à jour avec gameState
});

function gameReducer(state = initialState, action) {
  switch (action.type) {
    case "UPDATE_GAME_STATE":
      return state
        .set("grid", action.payload.grid)
        .set("currentPiece", action.payload.currentPiece)
        .set("score", action.payload.score)
        .set("mode", action.payload.mode); // Mettre à jour le mode
    default:
      return state;
  }
}

export default gameReducer;
-e 

==== ./src/pages/GameRoom.js ====
// ./src/pages/GameRoom.js

import React, { useEffect, useRef } from "react";
import { useParams } from "react-router-dom";
import { useSelector, useDispatch } from "react-redux";
import GameGrid from "../components/gameGrid/GameGrid";
import PlayerList from "../components/playerList/PlayerList";
import socket from "../socket";
import { updateGameState } from "../redux/actions/gameActions";
import "./GameRoom.css";

function GameRoom() {
  const { roomId } = useParams();
  const gameRoomRef = useRef(null);
  const score = useSelector((state) => state.game.get("score"));
  const mode = useSelector((state) => state.game.get("mode"));
  const dispatch = useDispatch();

  useEffect(() => {
    // Si roomId est présent, rejoindre la room
    if (roomId) {
      console.log("Rejoindre la room :", roomId); // Debug
      // L'événement 'joinGame' est déjà émis depuis Home.js
      // Donc, pas besoin de l'émettre ici
    }

    // Gérer les déconnexions
    return () => {
      if (roomId) {
        socket.emit("leaveRoom", { roomId });
      }
      socket.disconnect();
    };
  }, [roomId]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      switch (e.key) {
        case "ArrowLeft":
          socket.emit("movePiece", "left");
          break;
        case "ArrowRight":
          socket.emit("movePiece", "right");
          break;
        case "ArrowDown":
          socket.emit("movePiece", "down");
          break;
        case "ArrowUp":
          socket.emit("rotatePiece");
          break;
        case " ":
          socket.emit("dropPiece");
          break;
        default:
          break;
      }
    };

    // Attacher l'écouteur d'événements clavier au conteneur de GameRoom
    const currentRef = gameRoomRef.current;
    if (currentRef) {
      currentRef.addEventListener("keydown", handleKeyDown);
      currentRef.focus();
    }

    // Nettoyage
    return () => {
      if (currentRef) {
        currentRef.removeEventListener("keydown", handleKeyDown);
      }
    };
  }, []);

  return (
    <div
      className="game-room"
      ref={gameRoomRef}
      tabIndex="0" // Permet de recevoir les événements clavier
      style={{ outline: "none" }} // Supprimer le contour de focus par défaut
    >
      <h1>Salle de Jeu - {roomId}</h1>
      <GameGrid />
      {mode === "multiplayer" && <PlayerList />}{" "}
      {/* Afficher uniquement en multijoueur */}
      <div className="score-board">
        <h2>Score: {score}</h2>
      </div>
    </div>
  );
}

export default GameRoom;
-e 

==== ./src/pages/Home.css ====
/* ./src/pages/Home.css */

.home-page {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
}

.mode-selection,
.multiplayer-options {
  margin-top: 20px;
}

.mode-selection button,
.multiplayer-options button {
  margin: 10px;
  padding: 10px 20px;
  font-size: 1rem;
  cursor: pointer;
}
-e 

==== ./src/pages/GameRoom.css ====
/* ./src/pages/GameRoom.css */

.game-room {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  outline: none; /* Supprimer le contour de focus par défaut */
}

.score-board {
  margin-top: 20px;
}
-e 

==== ./src/pages/Home.js ====
// ./src/pages/Home.js

import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import socket from "../socket";
import "./Home.css";
import RoomList from "../components/RoomList";
import CreateRoom from "../components/CreateRoom";

function Home() {
  const [mode, setMode] = useState(null);
  const [rooms, setRooms] = useState([]);
  const navigate = useNavigate();

  useEffect(() => {
    if (mode === "multiplayer") {
      // Demander la liste des rooms disponibles
      socket.emit("getAvailableRooms");
    }
  }, [mode]);

  useEffect(() => {
    // Écouter les rooms disponibles
    socket.on("availableRooms", (availableRooms) => {
      setRooms(availableRooms);
    });

    // Écouter les créations de room
    socket.on("roomCreated", ({ roomId }) => {
      navigate(`/room/${roomId}`);
    });

    // Écouter les erreurs
    socket.on("error", (message) => {
      alert(message);
    });

    return () => {
      socket.off("availableRooms");
      socket.off("roomCreated");
      socket.off("error");
    };
  }, [navigate]);

  const handleModeSelection = (selectedMode) => {
    setMode(selectedMode);
    if (selectedMode === "solo") {
      // Émettre l'événement pour rejoindre en solo
      socket.emit("joinGame", { mode: "solo" });
    } else if (selectedMode === "multiplayer") {
      // Émettre l'événement pour rejoindre en multijoueur
      // La liste des rooms sera demandée via l'effet précédent
    }
  };

  return (
    <div className="home-page">
      <h1>Bienvenue sur Red Tetris</h1>
      {!mode && (
        <div className="mode-selection">
          <button onClick={() => handleModeSelection("solo")}>
            Jouer en Solo
          </button>
          <button onClick={() => handleModeSelection("multiplayer")}>
            Jouer en Multijoueur
          </button>
        </div>
      )}
      {mode === "multiplayer" && (
        <div className="multiplayer-options">
          <CreateRoom />
          <RoomList rooms={rooms} />
        </div>
      )}
    </div>
  );
}

export default Home;
-e 

==== ./src/index.js ====
// ./src/index.js

import React from "react";
import ReactDOM from "react-dom";
import App from "./App";
import { BrowserRouter } from "react-router-dom";
import { Provider, useDispatch } from "react-redux";
import store from "./redux/store";
import socket from "./socket";
import { updateGameState } from "./redux/actions/gameActions";

const SocketListener = ({ children }) => {
  const dispatch = useDispatch();

  React.useEffect(() => {
    // Écouter l'événement 'gameState' depuis le serveur
    socket.on("gameState", (gameState) => {
      console.log("Reçu gameState :", gameState); // Debug
      dispatch(updateGameState(gameState));
    });

    // Écouter l'événement 'gameStarted'
    socket.on("gameStarted", ({ roomId }) => {
      console.log(`La partie dans la room ${roomId} a commencé.`);
      // Vous pouvez ajouter ici des actions supplémentaires si nécessaire
    });

    // Nettoyage à la déconnexion
    return () => {
      socket.off("gameState");
      socket.off("gameStarted");
    };
  }, [dispatch]);

  return children;
};

ReactDOM.render(
  <Provider store={store}>
    <BrowserRouter>
      <SocketListener>
        <App />
      </SocketListener>
    </BrowserRouter>
  </Provider>,
  document.getElementById("root")
);
-e 

==== ./src/setupTests.js ====
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';
-e 

==== ./src/app.css ====
/* ./src/App.css : Styles pour l’application, notamment pour l’affichage du score. */
.score-display {
  position: fixed;
  top: 10px;
  right: 10px;
  background-color: rgba(255, 255, 255, 0.8);
  padding: 10px;
  border-radius: 5px;
}
-e 

==== ./src/components/CreateRoom.js ====
// ./src/components/CreateRoom.js

import React from "react";
import socket from "../socket";

function CreateRoom() {
  const handleCreateRoom = () => {
    socket.emit("joinGame", { mode: "multiplayer" });
  };

  return (
    <div className="create-room">
      <button onClick={handleCreateRoom}>Créer une Nouvelle Partie</button>
    </div>
  );
}

export default CreateRoom;
-e 

==== ./src/components/RoomList.css ====
/* ./src/components/RoomList.css */

.room-list {
  margin-top: 20px;
}

.room-list ul {
  list-style-type: none;
  padding: 0;
}

.room-list li {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 10px;
}

.room-list button {
  padding: 5px 10px;
  cursor: pointer;
}
-e 

==== ./src/components/RoomList.js ====
// ./src/components/RoomList.js : Afficher les parties multijoueurs disponibles que les joueurs peuvent rejoindre.

import React from "react";
import socket from "../socket";
import { useNavigate } from "react-router-dom";

function RoomList({ rooms }) {
  const navigate = useNavigate();

  const handleJoinRoom = (roomId) => {
    socket.emit("joinGame", { mode: "multiplayer", roomId });
    navigate(`/room/${roomId}`);
  };

  return (
    <div className="room-list">
      <h2>Parties Disponibles</h2>
      {rooms.length === 0 ? (
        <p>Aucune partie disponible. Créez-en une nouvelle !</p>
      ) : (
        <ul>
          {rooms.map((room) => (
            <li key={room.roomId}>
              <span>Room ID: {room.roomId}</span>
              <span>Joueurs: {room.players}/2</span>
              <button onClick={() => handleJoinRoom(room.roomId)}>
                Rejoindre
              </button>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}

export default RoomList;
-e 

==== ./src/components/playerList/PlayerList.js ====
// ./src/components/playerList/PlayerList.js : Affiche la liste des joueurs connectés (actuellement statique).

import React from "react";
import "./PlayerList.css";

function PlayerList() {
  const players = ["Player 1", "Player 2", "Player 3"]; // Exemple de données

  return (
    <div className="player-list">
      <h2>Liste des joueurs</h2>
      <ul>
        {players.map((player, index) => (
          <li key={index}>{player}</li>
        ))}
      </ul>
    </div>
  );
}

export default PlayerList;
-e 

==== ./src/components/playerList/PlayerList.css ====
/* ./src/components/playerList/PlayerList.css */
.player-list {
  margin: 20px;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 5px;
  background-color: #f9f9f9;
  width: 200px;
}

.player-list h2 {
  font-size: 1.2rem;
  margin-bottom: 10px;
  color: #333;
}

.player-list ul {
  list-style-type: none;
  padding: 0;
}

.player-list li {
  padding: 8px;
  border-bottom: 1px solid #ddd;
  font-size: 1rem;
  color: #555;
}

.player-list li:last-child {
  border-bottom: none;
}
-e 

==== ./src/components/gameGrid/GameGrid.css ====
/* ./src/components/gameGrid/GameGrid.css */
.game-grid {
  display: grid;
  grid-template-rows: repeat(20, 1fr);
  grid-template-columns: repeat(10, 1fr);
  gap: 1px;
  background-color: #333;
  width: 200px;
  height: 400px;
  margin: auto;
}

.grid-row {
  display: contents;
}

.grid-cell {
  background-color: #fff;
  border: 1px solid #ddd;
  width: 100%;
  height: 100%;
}

.grid-cell.filled {
  background-color: #333; /* Couleur de remplissage pour les cellules occupées */
}
-e 

==== ./src/components/gameGrid/GameGrid.js ====
// ./src/components/gameGrid/GameGrid.js

import React from "react";
import { useSelector } from "react-redux"; // Assurez-vous que cette ligne est présente et correcte
import "./GameGrid.css";

function GameGrid() {
  // Récupérer la grille et la pièce actuelle depuis Redux
  const grid = useSelector((state) => state.game.get("grid"));
  const currentPiece = useSelector((state) => state.game.get("currentPiece"));

  if (!grid || !currentPiece) {
    return <div className="game-grid">Chargement...</div>;
  }

  // Superposer la pièce actuelle sur la grille
  const updatedGrid = grid.map((row, y) =>
    row.map((cell, x) => {
      if (
        currentPiece &&
        currentPiece.shape[y - currentPiece.y] &&
        currentPiece.shape[y - currentPiece.y][x - currentPiece.x] === 1
      ) {
        return 1; // Cellule occupée par la pièce actuelle
      }
      return cell;
    })
  );

  return (
    <div className="game-grid">
      {updatedGrid.map((row, rowIndex) => (
        <div key={rowIndex} className="grid-row">
          {row.map((cell, colIndex) => (
            <div
              key={colIndex}
              className={`grid-cell ${cell ? "filled" : ""}`}
            ></div>
          ))}
        </div>
      ))}
    </div>
  );
}

export default GameGrid;
-e 

==== ./src/socket.js ====
// ./src/socket.js : Configure et exporte l’instance Socket.io pour être utilisée dans les composants React.

import { io } from "socket.io-client";
const socket = io(process.env.REACT_APP_SOCKET_SERVER); // Utiliser la variable d'environnement

export default socket;
-e 

==== ./src/reportWebVitals.js ====
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;
-e 

==== ./src/App.js ====
// ./src/App.js

import { Route, Routes } from "react-router-dom";
import Home from "./pages/Home";
import GameRoom from "./pages/GameRoom";
import { useSelector } from "react-redux";

function App() {
  // Utilisation de Redux pour afficher le message de test
  const message = useSelector((state) => state.test.get("message"));
  const score = useSelector((state) => state.game.get("score"));

  return (
    <div className="App">
      <h1>{message}</h1>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/room/:roomId" element={<GameRoom />} />
      </Routes>
      <div className="score-display">
        <h2>Score: {score}</h2>
      </div>
    </div>
  );
}

export default App;
-e 

==== ./src/App.test.js ====
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});
-e 

==== ./server/index.js ====
// ./server/index.js

const express = require("express");
const http = require("http");
const { Server } = require("socket.io");
const handleGameEvents = require("./sockets/gameEvents");
const { players } = require("./game/playerManager");
const { rooms } = require("./game/roomManager");

const {
  movePiece,
  stackPiece,
  clearCompleteLines,
  generateRandomPiece,
} = require("./game/gameLogic");

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
  cors: {
    origin: "*", // Pour les tests en local ; ajuster pour des déploiements
    methods: ["GET", "POST"],
  },
});

const PORT = process.env.PORT || 4000;

// Vérifier que `rooms` est bien importé
console.log("Imported rooms in index.js:", rooms);

// Gérer les connexions socket.io
io.on("connection", (socket) => {
  console.log(`Nouvelle connexion établie : ${socket.id}`);
  handleGameEvents(socket, io); // Gérer les événements du jeu pour ce socket
});

// Boucle de jeu principale
setInterval(() => {
  // Vérifie si `rooms` est défini
  if (!rooms) {
    console.error("Erreur : `rooms` n'est pas défini !");
    return;
  }

  // Pour chaque room
  Object.keys(rooms).forEach((roomId) => {
    const room = rooms[roomId];
    if (room.status !== "in-progress") return; // Ne traiter que les salles en cours

    room.players.forEach((playerId) => {
      const player = players[playerId];
      if (player && player.currentPiece) {
        const newPiece = movePiece(player.currentPiece, "down", player.grid);
        if (newPiece) {
          player.currentPiece = newPiece;
        } else {
          // Empiler la pièce sur la grille
          player.grid = stackPiece(player.grid, player.currentPiece);
          player.currentPiece = generateRandomPiece();
          // Vérifier et supprimer les lignes complètes
          player.grid = clearCompleteLines(player.grid);
          // Mettre à jour le score
          player.score += 100;
        }
        // Émettre l'état du jeu mis à jour uniquement au joueur concerné
        io.to(playerId).emit("gameState", player);
      }
    });
  });
}, 1000); // Chute toutes les secondes

// Lancer le serveur
server.listen(PORT, () => {
  console.log(`Serveur socket.io lancé sur le port ${PORT}`);
});
-e 

==== ./server/config/constants.js ====
// ./server/config/constants.js
// Configuration des constantes du jeu
module.exports = {
  GRID_WIDTH: 10,
  GRID_HEIGHT: 20,
  // Autres constantes si nécessaire
};
-e 

==== ./server/game/roomManager.js ====
// ./server/game/roomManager.js

const { v4: uuidv4 } = require("uuid");

const rooms = {};
const MAX_PLAYERS = 2; // Limite de joueurs par salle

/**
 * Crée une nouvelle room et retourne son identifiant unique.
 * @param {string} hostId - ID du joueur qui crée la room.
 * @returns {string} roomId - Identifiant unique de la room.
 */
function createRoom(hostId) {
  const roomId = uuidv4();
  rooms[roomId] = {
    host: hostId,
    players: [hostId],
    status: "waiting", // 'waiting' ou 'in-progress'
    grid: {},
    scores: {},
  };
  return roomId;
}

/**
 * Permet à un joueur de rejoindre une room existante.
 * @param {string} roomId - ID de la room à rejoindre.
 * @param {string} playerId - ID du joueur qui rejoint.
 * @returns {boolean} - Succès ou échec de l'opération.
 */
function joinRoom(roomId, playerId) {
  const room = rooms[roomId];
  if (
    room &&
    room.status === "waiting" &&
    room.players.length < MAX_PLAYERS &&
    !room.players.includes(playerId) // Vérifier que le joueur n'est pas déjà dans la salle
  ) {
    room.players.push(playerId);
    room.scores[playerId] = 0;
    room.grid[playerId] = Array.from({ length: 20 }, () => Array(10).fill(0));
    return true;
  }
  return false;
}

/**
 * Permet à un joueur de quitter une room.
 * @param {string} roomId - ID de la room.
 * @param {string} playerId - ID du joueur qui quitte.
 */
function leaveRoom(roomId, playerId) {
  const room = rooms[roomId];
  if (room) {
    room.players = room.players.filter((id) => id !== playerId);
    delete room.grid[playerId];
    delete room.scores[playerId];
    if (room.players.length === 0) {
      delete rooms[roomId];
    } else if (room.host === playerId) {
      room.host = room.players[0];
    }
  }
}

/**
 * Démarre une room en passant son statut à 'in-progress'.
 * @param {string} roomId - ID de la room à démarrer.
 * @returns {boolean} - Succès ou échec de l'opération.
 */
function startRoom(roomId) {
  const room = rooms[roomId];
  if (room && room.status === "waiting" && room.players.length >= MAX_PLAYERS) {
    room.status = "in-progress";
    return true;
  }
  return false;
}

/**
 * Retourne la liste des rooms disponibles pour rejoindre.
 * @returns {Array} - Liste des rooms disponibles.
 */
function getAvailableRooms() {
  return Object.entries(rooms)
    .filter(([_, room]) => room.status === "waiting")
    .map(([roomId, room]) => ({ roomId, players: room.players.length }));
}

module.exports = {
  createRoom,
  joinRoom,
  leaveRoom,
  startRoom,
  getAvailableRooms,
  rooms,
};
-e 

==== ./server/game/gameLogic.js ====
// ./server/game/gameLogic.js : Contient la logique de base du jeu (génération des pièces, mouvements, rotations, empilement, suppression des lignes).

const { GRID_WIDTH, GRID_HEIGHT } = require("../config/constants");

const TETROMINOS = {
  I: [[1, 1, 1, 1]],
  O: [
    [1, 1],
    [1, 1],
  ],
  T: [
    [0, 1, 0],
    [1, 1, 1],
  ],
  J: [
    [1, 0, 0],
    [1, 1, 1],
  ],
  L: [
    [0, 0, 1],
    [1, 1, 1],
  ],
  S: [
    [0, 1, 1],
    [1, 1, 0],
  ],
  Z: [
    [1, 1, 0],
    [0, 1, 1],
  ],
};

// Fonction pour générer une pièce aléatoire
const generateRandomPiece = () => {
  const pieces = Object.keys(TETROMINOS);
  const randomPiece = pieces[Math.floor(Math.random() * pieces.length)];
  return {
    shape: TETROMINOS[randomPiece],
    x:
      Math.floor(GRID_WIDTH / 2) -
      Math.floor(TETROMINOS[randomPiece][0].length / 2),
    y: 0, // Positionner la pièce en haut de la grille
  };
};

// Fonction pour déplacer une pièce dans une direction spécifique
function movePiece(piece, direction, grid) {
  let newX = piece.x;
  let newY = piece.y;

  switch (direction) {
    case "left":
      newX = piece.x - 1;
      break;
    case "right":
      newX = piece.x + 1;
      break;
    case "down":
      newY = piece.y + 1;
      break;
    default:
      break;
  }

  if (isValidPosition(grid, piece, newX, newY)) {
    return { ...piece, x: newX, y: newY };
  } else {
    // Si le mouvement vers le bas n'est pas possible, empiler la pièce
    if (direction === "down") {
      return null; // Indique que la pièce doit être empilée
    }
    return piece; // Aucun changement si le mouvement n'est pas possible
  }
}

// Fonction pour faire tourner une pièce
function rotatePiece(piece, grid) {
  const newShape = piece.shape[0].map((_, index) =>
    piece.shape.map((row) => row[index]).reverse()
  );

  const rotatedPiece = { ...piece, shape: newShape };

  if (isValidPosition(grid, rotatedPiece, rotatedPiece.x, rotatedPiece.y)) {
    return rotatedPiece;
  }

  return piece; // Retourner la pièce originale si la rotation n'est pas valide
}

// Fonction pour faire tomber rapidement une pièce
function dropPiece(piece, grid) {
  let newY = piece.y + 1;
  while (isValidPosition(grid, piece, piece.x, newY)) {
    newY += 1;
  }
  return { ...piece, y: newY - 1 };
}

// Vérifie si la pièce peut être placée à la position spécifiée
function isValidPosition(grid, piece, newX, newY) {
  for (let y = 0; y < piece.shape.length; y++) {
    for (let x = 0; x < piece.shape[y].length; x++) {
      if (piece.shape[y][x] === 1) {
        const gridX = newX + x;
        const gridY = newY + y;
        // Vérifier les limites de la grille
        if (
          gridX < 0 ||
          gridX >= GRID_WIDTH ||
          gridY >= GRID_HEIGHT ||
          (gridY >= 0 && grid[gridY][gridX] === 1)
        ) {
          return false;
        }
      }
    }
  }
  return true;
}

// Empile la pièce sur la grille
function stackPiece(grid, piece) {
  const newGrid = grid.map((row) => row.slice()); // Clone de la grille

  piece.shape.forEach((row, y) => {
    row.forEach((cell, x) => {
      if (cell === 1) {
        const gridX = piece.x + x;
        const gridY = piece.y + y;
        if (
          gridY >= 0 &&
          gridY < GRID_HEIGHT &&
          gridX >= 0 &&
          gridX < GRID_WIDTH
        ) {
          newGrid[gridY][gridX] = 1;
        }
      }
    });
  });

  return newGrid;
}

// Supprime les lignes complètes et renvoie la nouvelle grille
function clearCompleteLines(grid) {
  const newGrid = grid.filter((row) => row.some((cell) => cell === 0));
  const linesCleared = GRID_HEIGHT - newGrid.length;
  const emptyLines = Array(linesCleared)
    .fill(0)
    .map(() => Array(GRID_WIDTH).fill(0));
  return emptyLines.concat(newGrid);
}

module.exports = {
  TETROMINOS,
  generateRandomPiece,
  movePiece,
  rotatePiece,
  dropPiece,
  isValidPosition,
  stackPiece,
  clearCompleteLines,
};
-e 

==== ./server/game/playerManager.js ====
// ./server/game/playerManager.js

const { generateRandomPiece } = require("./gameLogic");
const { GRID_WIDTH, GRID_HEIGHT } = require("../config/constants");

const players = {};

/**
 * Ajoute un joueur et l'associe à une room.
 * @param {string} playerId - ID unique du joueur (socket.id)
 * @param {string} roomId - ID de la room
 * @param {string} mode - Mode de jeu ('solo' ou 'multiplayer')
 */
function addPlayer(playerId, roomId, mode = "multiplayer") {
  players[playerId] = {
    roomId,
    mode, // Mode de jeu
    grid: Array.from({ length: GRID_HEIGHT }, () => Array(GRID_WIDTH).fill(0)), // Initialise une grille vide
    currentPiece: generateRandomPiece(), // Assigne une pièce aléatoire
    score: 0,
  };
}

function removePlayer(playerId) {
  delete players[playerId];
}

module.exports = { addPlayer, removePlayer, players };
-e 

==== ./server/sockets/gameEvents.js ====
// ./server/sockets/gameEvents.js

const {
  movePiece,
  rotatePiece,
  generateRandomPiece,
  dropPiece,
  stackPiece,
  clearCompleteLines,
} = require("../game/gameLogic");
const { addPlayer, removePlayer, players } = require("../game/playerManager");
const {
  createRoom,
  joinRoom,
  leaveRoom,
  startRoom,
  getAvailableRooms,
  rooms,
} = require("../game/roomManager");

function handleGameEvents(socket, io) {
  // Lorsqu'un joueur rejoint
  socket.on("joinGame", ({ mode, roomId }) => {
    if (mode === "solo") {
      // Créer une salle unique pour le mode solo
      const soloRoomId = createRoom(socket.id);
      startRoom(soloRoomId); // Démarrer immédiatement en solo
      socket.join(soloRoomId);
      addPlayer(socket.id, soloRoomId, "solo"); // Passer le mode
      io.to(socket.id).emit("roomCreated", { roomId: soloRoomId });
      io.to(socket.id).emit("gameState", {
        roomId: soloRoomId,
        grid: players[socket.id].grid,
        currentPiece: players[socket.id].currentPiece,
        score: players[socket.id].score,
        mode: players[socket.id].mode,
      });
      console.log(`Room solo créée: ${soloRoomId} par ${socket.id}`);
    } else if (mode === "multiplayer") {
      if (roomId) {
        // Tenter de rejoindre une salle existante
        const success = joinRoom(roomId, socket.id);
        if (success) {
          socket.join(roomId);
          addPlayer(socket.id, roomId, "multiplayer"); // Passer le mode
          io.to(rooms[roomId].host).emit("roomJoined", {
            roomId,
            players: rooms[roomId].players.length,
          });
          console.log(`Joueur ${socket.id} a rejoint la room ${roomId}`);
          // Si la salle atteint le nombre de joueurs requis (2), démarrer la partie
          if (rooms[roomId].players.length >= 2) {
            startRoom(roomId);
            io.to(roomId).emit("gameStarted", { roomId });
            console.log(`Partie démarrée dans la room ${roomId}`);
            // Émettre l'état initial du jeu à tous les joueurs de la salle
            rooms[roomId].players.forEach((playerId) => {
              io.to(playerId).emit("gameState", {
                roomId,
                grid: players[playerId].grid,
                currentPiece: players[playerId].currentPiece,
                score: players[playerId].score,
                mode: players[playerId].mode,
              });
            });
          }
        } else {
          // Salle pleine ou inexistante
          io.to(socket.id).emit(
            "error",
            "La partie est pleine ou n'existe pas."
          );
          console.log(`Échec de rejoindre la room ${roomId} pour ${socket.id}`);
        }
      } else {
        // Créer une nouvelle salle multijoueur
        const newRoomId = createRoom(socket.id);
        socket.join(newRoomId);
        addPlayer(socket.id, newRoomId, "multiplayer"); // Passer le mode
        io.to(socket.id).emit("roomCreated", { roomId: newRoomId });
        console.log(
          `Nouvelle room multijoueur créée: ${newRoomId} par ${socket.id}`
        );
      }
    }
  });

  // Gérer les déplacements des pièces
  socket.on("movePiece", (direction) => {
    const player = players[socket.id];
    if (player && player.currentPiece) {
      const newPiece = movePiece(player.currentPiece, direction, player.grid);
      if (newPiece) {
        player.currentPiece = newPiece;
      } else {
        // Empiler la pièce sur la grille
        player.grid = stackPiece(player.grid, player.currentPiece);
        player.currentPiece = generateRandomPiece();
        // Vérifier et supprimer les lignes complètes
        player.grid = clearCompleteLines(player.grid);
        // Mettre à jour le score
        player.score += 100;
      }
      io.to(player.roomId).emit("gameState", {
        roomId: player.roomId,
        grid: player.grid,
        currentPiece: player.currentPiece,
        score: player.score,
        mode: player.mode,
      });
    }
  });

  // Gérer la rotation des pièces
  socket.on("rotatePiece", () => {
    const player = players[socket.id];
    if (player && player.currentPiece) {
      const rotatedPiece = rotatePiece(player.currentPiece, player.grid);
      player.currentPiece = rotatedPiece;
      io.to(player.roomId).emit("gameState", {
        roomId: player.roomId,
        grid: player.grid,
        currentPiece: player.currentPiece,
        score: player.score,
        mode: player.mode,
      });
    }
  });

  // Gérer la chute rapide des pièces
  socket.on("dropPiece", () => {
    const player = players[socket.id];
    if (player && player.currentPiece) {
      const droppedPiece = dropPiece(player.currentPiece, player.grid);
      if (droppedPiece) {
        player.currentPiece = droppedPiece;
      } else {
        // Empiler la pièce sur la grille
        player.grid = stackPiece(player.grid, player.currentPiece);
        player.currentPiece = generateRandomPiece();
        // Vérifier et supprimer les lignes complètes
        player.grid = clearCompleteLines(player.grid);
        // Mettre à jour le score
        player.score += 100;
      }
      io.to(player.roomId).emit("gameState", {
        roomId: player.roomId,
        grid: player.grid,
        currentPiece: player.currentPiece,
        score: player.score,
        mode: player.mode,
      });
    }
  });

  // Lorsqu'un joueur se déconnecte
  socket.on("disconnect", () => {
    const player = players[socket.id];
    if (player) {
      const roomId = player.roomId;
      leaveRoom(roomId, socket.id);
      removePlayer(socket.id);
      // Informer les autres joueurs de la salle
      io.to(roomId).emit("playerLeft", { playerId: socket.id });
      console.log(`Joueur ${socket.id} a quitté la room ${roomId}`);
    }
    console.log("Joueur déconnecté :", socket.id);
  });
}

module.exports = handleGameEvents;
-e 

==== ./print.sh ====
#!/bin/bash

# Définir le dossier de travail comme le répertoire courant
directory="."

# Fichier de sortie
output_file="./print_out.txt"

# Vider le fichier de sortie s'il existe déjà pour éviter une accumulation
> "$output_file"

# Trouver tous les fichiers en excluant node_modules, public, yarn.lock, et .git
find "$directory" -type f ! -path "./node_modules/*" ! -path "./public/*" ! -path "./.git/*" ! -name "yarn.lock" ! -name ".gitignore" ! -name "README.md" | while read -r file; do
    echo "==== $file ====" >> "$output_file"
    cat "$file" >> "$output_file"
    echo -e "\n" >> "$output_file"
done
-e 

==== ./print_out.txt ====
-e 

